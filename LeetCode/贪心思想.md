贪心
====
[402.移掉K位数字](#移掉K位数字)


移掉K位数字
===========
[leetcode](https://leetcode-cn.com/problems/remove-k-digits/)
给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。
### 示例
```
输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。

输入: num = "10200", k = 1
输出: "200"
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。

输入: num = "10", k = 2
输出: "0"
解释: 从原数字移除所有的数字，剩余为空就是0。
```

### 解题思路
* 例如 425，如果要求我们只删除一个数字，那么从左到右，我们有 4、2 和 5 三个选择。我们将每一个数字和它的左邻居进行比较。
从 2 开始，2 小于它的左邻居 4。假设我们保留数字 4，那么所有可能的组合都是以数字 4开头的。
如果移掉 4，留下 2，我们得到的是以 2 开头的组合，这明显小于任何留下数字 4 的组合。
因此我们应该移掉数字 4。如果不移掉数字 4，则之后无论移掉什么数字，都不会得到最小数。
* 贪心思想：维护一个栈，遍历每个数字，当数字大于栈顶元素时入栈，如果发现一个数小于栈顶元素，就将栈里的元素弹出，直到栈里没有比它还小的为止
* 注意去除前导零和k的次数是否用完，如果整个数列都是单调递增的，那么就从后面删除k个数字
```cpp
    string removeKdigits(string num, int k) {
        if (num.size() == 1) return "0";
        stack<char> sck;
        sck.push(num[0]);
        // 栈顶元素进行比较，小于栈顶元素，栈顶出栈
        for (int i = 1; i < num.size(); ++i) {
            while (!sck.empty() && num[i] < sck.top() && k > 0) {
                sck.pop();
                k--;
            }   
            sck.push(num[i]);
        }

        // 用完剩余k的次数
        while (k-- && !sck.empty()) {
            sck.pop();
        }

        // 输出答案
        string res;
        while (!sck.empty()) {
            res += sck.top();
            sck.pop();
        }
        reverse(res.begin(), res.end());

        // 去除前导0
        int i = 0;
        while (res[i] == '0') i++;
        res.erase(res.begin(), res.begin() + i);

        return res.empty() ? "0" : res;
    }

```

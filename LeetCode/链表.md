链表  
=========
* [1.删除链表的倒数第N个节点](#19. 删除链表的倒数第N个节点)
* [2.合并两个有序链表](#21.合并两个有序链表)
* [1.]()
* [1.]()
* [1.]()

19.删除链表的倒数第N个节点
====================
[Leetcode](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)  给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。
### 解题思路
* 使用快慢指针法，让快指针提前先走n+1步，再同步快慢指针直到快指针指向链表结尾时，慢指针刚好停留在需要删除结点的前驱。
* 添加头结点 `dummy` 是为了统一对链表增删的操作。
* 删除结点相当于链接时跳过此结点
```cpp
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy=new ListNode(-1);
        dummy->next=head;
        ListNode* fast=dummy;
        ListNode* slow=dummy；
        int cnt=n+1;
        while(cnt--){
            fast=fast->next;
        }
        while(fast){
            fast=fast->next;
            slow=slow->next;
        }
        slow->next=slow->next->next;
        return dummy->next;
    }
```
21.合并两个有序链表
==============
[Leetcode](https://leetcode-cn.com/problems/merge-two-sorted-lists/)将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
### 解题思路
* 合并为一个新的链表用尾插法，三个指针：l1，l2用于遍历两个链表，cur用于遍历新的链表
* 涉及新建链表一般都需要new一个头结点和定义一个指针用于遍历。
* 同时遍历两个链表，把比较小的结点用尾插法插入到新的链表中，再更新指针。
*  `while`结束标志为：其中一个链表遍历结束
* 如果一个链表遍历结束，另一个未结束，则把未结束的剩余部分链接上
```cpp
     ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* head=new ListNode(-1);
        ListNode* cur=head;
        //尾插法
        while(l1 && l2){
            if(l1->val <= l2->val){
                cur->next=l1;
                l1=l1->next;
            }else{
                cur->next=l2;
                l2=l2->next;
            }
            cur=cur->next;
        }
        if(!l1) cur->next=l2;
        if(!l2) cur->next=l1;
        return head->next;
    }
```
24.两两交换链表中的节点
===============
[Leetcode](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
### 示例
```
给定 1->2->3->4, 你应该返回 2->1->4->3.
```
### 解题思路
* 使用头节点，用于链表第一结点与其他结点增删改的统一。
* 定义三个指针，cur用于遍历原链表，p1,p2用于交换（p2指向p1的后继结点）
* 链接的顺序：1->3  2->1 cur->2
* 注意：cur指针每次向前跳两步。
```cpp
     ListNode* swapPairs(ListNode* head) {
        ListNode* dummy=new ListNode(-1);
        dummy->next=head;
        ListNode* cur=dummy;
        ListNode* p1=dummy;
        ListNode* p2=dummy;
        while(cur->next && cur->next->next){
            p1=cur->next;
            p2=cur->next->next;
            p1->next=p2->next;
            p2->next=p1;
            cur->next=p2;
            cur=cur->next->next;
        }
        return dummy->next;
    }
```



83.删除排序链表中的重复元素  
===========================    
[Leetcode](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
### 解题思路
*  链表中删除一个结点相当于指针越过该结点（next指针指向要删除结点的后继）
*  直到cur与下一个结点值不同时，更新指针
```cpp
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* cur=head;
        while(cur && cur->next){
            if(cur->val == cur->next->val) 
	cur->next=cur->next->next;
            else 
	cur=cur->next; 
        }
        return head;
    }
```


反转链表  
============
[Leetcode](https://leetcode-cn.com/problems/reverse-linked-list/)   
递归法：
* reverseList函数返回值为反转后的链表头部，即链表的最后一个节点
* 想象各节点的位置不变，每层的步骤只是反转一次当前节点 `head`和他的下一个节点`head->next`的指针方向而已。  
```cpp
 ListNode* reverseList(ListNode* head) {
        if(!head)return head;
        //如果链表只有一个节点时,直接返回头部
        if(!head->next)return head;
        ListNode*newHead=reverseList(head->next);
        //让后面的节点反向指向自己
        head->next->next=head;
        //让自己作为链表尾部，指向NULL
        head->next=NULL;
        return newHead;
    }
```
迭代法：
* 链表的头插法实现反转
* 需要两个指针，当前指针`cur`,新链表头部指针`pre`
* 因为需要改变当前结点next指针指向pre，所以必须先记录下next指针最后再恢复，才能让cur继在链表种、中遍历下去  
```cpp
    ListNode* reverseList(ListNode* head) {
        ListNode*cur=head;
        ListNode* pre=NULL;
        while(cur){
            ListNode*tmp=cur->next;
            cur->next=pre;
            pre=cur;
            cur=tmp;
        }
        return pre;
    }
```

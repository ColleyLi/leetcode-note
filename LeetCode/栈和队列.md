🚑栈和队列🚑
=======
* [7.整数反转](#整数反转) 
* [9.回文数](#回文数)
* [20.有效的括号](#有效的括号) 
* [232.用栈实现队列](#用栈实现队列)
* [225.用队列实现栈](#用队列实现栈)
* [155.最小栈](#最小栈)   
* [150.逆波兰表达式求值](#逆波兰表达式求值)
* [394.字符串解码](#字符串解码)

整数反转
===============
[Leetcode](https://leetcode-cn.com/problems/reverse-integer/)给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转
### 解题思路
* 从低到高位依次加入队列，然后输出
* 注意反转后的溢出问题
```cpp
int reverse(int x) {
    int rev=0;
    while(x!=0){
        if(rev>INT_MAX/10 || rev<INT_MIN/10) return 0;
        rev=rev*10+x%10;
         x/=10;
     }
     return rev;
}
```


回文数
=========
[Leetcode](https://leetcode-cn.com/problems/palindrome-number/)判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
### 解题思路
* 一位数一定是回文数
* 负数或者个位是0的一定不是回文数。
* 反转整数，只反转到一半，然后进行比较（对于奇数个数得回文数，去掉中间位再比较）
```cpp
    bool isPalindrome(int x) {
        if(x>=0 && x<=9)return true;
        if(x%10==0 || x<0)return false;
        int rev=0;
        while(x>rev){
            rev=rev*10+x%10;
            x/=10;
        }
        return rev/10==x || rev==x;
    }
```

有效的括号
======
[Leetcode](https://leetcode-cn.com/problems/valid-parentheses/)给定一个只包括 '('，')'，'{'，'}'，'['，']' ===的字符串，判断字符串是否有效。
有效字符串需满足：
```
1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
```
注意空字符串可被认为是有效字符串。
### 解题思路
* 个数为奇数肯定不对
* 首字符为右符号肯定不对
* 遇到左符号入栈
* 遇到右符号与栈顶元素进行匹配，配对则出栈，否则返回false，最后栈空了则说明是有效的
```cpp
     bool isValid(string s) {
        if(s.size()%2)return false;
        if(s[0]=='}' || s[0]==')' || s[0]==']') return false;
        stack<char> sck;
        for(int i=0;s[i]!='\0';++i){
            if(s[i]=='[' || s[i]=='{' || s[i]=='('){
                sck.push(s[i]);
            }else{
                if(s[i]=='}' && sck.top()!='{') return false;
                if(s[i]==']' && sck.top()!='[') return false;
                if(s[i]==')' && sck.top()!='(') return false;
                sck.pop();
            }
        } 
        return sck.empty();
    }
```


用栈实现队列
=========
[Leetcode](https://leetcode-cn.com/problems/implement-queue-using-stacks/)  
* 栈的顺序为后进先出，而队列的顺序为先进先出。
* 使用两个栈实现队列，一个元素需要经过两个栈才能出队列
```cpp
class MyQueue {
public:   
    void push(int x) {
        stack1.push(x);
    }
    
    int pop() {
       if(stack2.empty()){                  //只有当stack2为空时，才重新加载
            while(!stack1.empty()){         //stack1装填到stack2
                stack2.push(stack1.top());  //c++ pop()函数返回值额为void
                stack1.pop();
            }
        }
        int res=stack2.top();
        stack2.pop();
        return res;
    }
    
    int peek() {
        if(stack2.empty()){
            while(!stack1.empty()){
                stack2.push(stack1.top());
                stack1.pop();
            }
        }
        return stack2.top();
    }
    
    bool empty() {
        return stack1.empty() && stack2.empty();
    }
private:
    stack<int> stack1;
    stack<int> stack2;
};

```  

用队列实现栈
============
方法一
----------
[Leetcode](https://leetcode-cn.com/problems/implement-stack-using-queues/)  
* 一个队列  
* push之前判断当前是否为空
* 不为空则将元素插入到尾部，前面的全部弹出再去入队
* `push`时间复杂度O(n),而`pop`的时间复杂度O(1)    

```cpp
class MyStack {
public:
    MyStack() {}
    
    void push(int x) {
        if(queue1.empty()){
            queue1.push(x);
        }else{
            int cnt=queue1.size();
            queue1.push(x);
            while(cnt-->0){
                queue1.push(queue1.front());
                queue1.pop();
            }
        }
    }
    
    int pop() {
        int res=queue1.front();
        queue1.pop();
        return res;
    }
    
    int top() {
        return queue1.front();
    }
    
    bool empty() {
        return queue1.empty();
    }
private:
    queue<int> queue1;
};

```
方法二
--------
* `push`时间复杂度O(1),而`pop`的时间复杂度O(n)  
```cpp
private:
    queue<int> q1; 
    void push(int x) {
        q1.push(x);
    }
    int pop() {
        queue<int>q2;
        while(q1.size()>1){
            q2.push(q1.front());
            q1.pop();
        }
        int res=q1.front();
        q1=q2;
        return res;
    }   
    int top() {
        queue<int>q2(q1);
        while(q1.size()>1){
            q1.pop();
        }
        int res=q1.front();
        q1=q2;
        return res;
    }
    bool empty() {
        return q1.empty();
    }
};
```
最小栈  
=============
[Leetcode](https://leetcode-cn.com/problems/min-stack/)  
* 维护两个栈：`数据栈` `最小栈`
* 同步简单，异步节省`最小栈`空间
* 异步：当新插入的元素比最小值还小（或相等）时，插入最小栈，出栈时只有当两个栈栈顶元素相同时，两个栈同时pop，否则只有`数据栈`pop  
* 同步：两个栈的大小始终相同，只是`最小栈`每次都插入当前最小值，出栈时两栈同时pop  

```cpp
class MinStack {
public: 
    void push(int x) {
        dataStack.push(x);
        if(miniStack.empty()){
            miniStack.push(x);
        }else{
            int min=miniStack.top();
            if(min>=x){                         //相等时也要插入
                miniStack.push(x);
            }
        }
    }
    
    void pop() {
        if( dataStack.top()==miniStack.top()){  //只有相等时才同时弹出否则只弹出dataStack
            dataStack.pop();
            miniStack.pop();
        }else{
            dataStack.pop();
        }
    }
    
    int top() {
        return dataStack.top();
    }
    
    int getMin() {
        return miniStack.top();
    }
private:
    stack<int> dataStack;
    stack<int> miniStack;
};

```

逆波兰表达式求值
==============
[leetcode](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)根据 逆波兰表示法，求表达式的值。
有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
说明：
整数除法只保留整数部分。
给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。
### 示例
```
输入: ["2", "1", "+", "3", "*"]
输出: 9
解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```
### 解题思路
* 典型的后缀表达式，栈得应用场景
* 遍历字符串数组，遇到字符就弹出栈顶两个元素进行运算，再将结果填入栈。遇到数字就直接入栈
* 这里使用了c语言`stoi()`函数直接将字符串转换为数字，也可以使用ASCII值转，`atoi(string.c_str())`
```cpp
    int evalRPN(vector<string>& tokens) {
        stack<int> sck;
        for (auto it : tokens) {
            if (it == "+") {
                int a = sck.top();
                sck.pop();
                int b = sck.top();
                sck.pop();
                sck.push(b + a);
            } else if (it == "-") {
                int a = sck.top();
                sck.pop();
                int b = sck.top();
                sck.pop();
                sck.push(b - a);
            } else if (it == "*"){
                int a = sck.top();
                sck.pop();
                int b = sck.top();
                sck.pop();
                sck.push(a * b);
            } else if (it == "/"){
                int a = sck.top();
                sck.pop();
                int b = sck.top();
                sck.pop();
                sck.push(b / a);
            } else {
                sck.push(stoi(it));
            }
        }
        return sck.top();
    }
```

字符串解码
==========
[leetcode](https://leetcode-cn.com/problems/decode-string/)给定一个经过编码的字符串，返回它解码后的字符串。
编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。
你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。
此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。
### 示例
```
输入：s = "3[a]2[bc]"
输出："aaabcbc"

输入：s = "3[a2[c]]"
输出："accaccacc"
```
### 解题思路
* 一看到`[` `]` 匹配得题，首先想到使用栈，既有数字又有字母，想到使用两个栈
* 这类题基本思路就是找到什么时候入栈，什么时候出栈。
* 同时涉及了遍历数组，提取数字和提取字符串算法
* 本题的当遍历到'['时同时入栈，遍历到']'时出栈进行操作,strSck.top()可以理解为到当前为止前面已经展开的字符串，cur为刚刚`[ ]`中合成的字符串。
* 讲道理此题过于难以理解🐛
```cpp
    string decodeString(string s) {
        string cur = "";
        stack<int> numSck;
        stack<string> strSck;
        int val = 0;
        for (int i = 0; s[i] != '\0'; ++i) {
            if (s[i] >= '0' && s[i] <= '9') {
                val = val * 10 + s[i] - '0';
            } else if (s[i] == '[') {
                numSck.push(val);
                strSck.push(cur);
                val = 0;
                cur = "";
            } else if ((s[i] >= 'a' && s[i] <='z') || (s[i] >= 'A' && s[i] <= 'Z')) {
                cur += s[i];
            } else if (s[i] == ']') {
                int cnt = numSck.top();
                numSck.pop();
                for (int i = 0; i < cnt; ++i) {
                    strSck.top() += cur;
                }
                cur = strSck.top();
                strSck.pop();
            }
        }
        return cur;
    }
```

133. 克隆图
========
[leetcode](https://leetcode-cn.com/problems/clone-graph/)给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。
图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。
```cpp
    Node* isClone[101];
    Node* cloneGraph(Node* node) {
        if (node == NULL) return NULL;
        if (isClone[node->val] != NULL) return isClone[node->val];
        Node* newNode = new Node(node->val);
        isClone[node->val] = newNode;
        for (auto it : node->neighbors) {
            newNode->neighbors.push_back(cloneGraph(it));
        }
        return newNode;
    }
```
🎨程序员面试金典🎨
==================

* [1.判定字符是否唯一](#判定字符是否唯一)
* [2.判定是否互为字符重排](#判定是否互为字符重排)
* [3.URL化](#URL化)
* [4.回文排列](#回文排列)
* [5.一次编辑](#一次编辑)
* [6.字符串压缩](#字符串压缩)
* [7.旋转矩阵](#旋转矩阵)









判定字符是否唯一
=================
[leetcode](https://leetcode-cn.com/problems/is-unique-lcci/)实现一个算法，确定一个字符串 s 的所有字符是否全都不同。

### 解题思路
* 首先想到哈希表统计各字母出现频率，只遍历一次，频率大于1就返回false。
```cpp
    bool isUnique(string astr) {
        unordered_map<char, int> cnt;
        for (int i = 0; i < astr.size(); ++i) {
            cnt[astr[i]]++;
            if (cnt[astr[i]] > 1) return false;
        }
        return true;
    }
```
* 如果面试官不想用哈希表，或者不能用额外的数据结构解题，就用一个整形数组代替来记录26个字母出现次数。
```cpp
    bool isUnique(string astr) {
        int cnt[26];
        memset(cnt, 0, sizeof(int) * 26);
        for (int i = 0; i < astr.size(); ++i) {
            cnt[astr[i] - 'a']++;
            if (cnt[astr[i] - 'a'] > 1) return false;
        }
        return true;
    }
```
* 但是对于这种统计只出现一次，或者两次的题，都能够给位运算符操作
* 本题的思路是，把每个字母转换成二进制，例如 `a-> 0001 b -> 0010 c-> 0100 d->1000`一次类推剩下所有字母。
* 还需要维护一个掩码mask，将遍历过的所有字母的二进制数合并起来(|=运算)，`例如遍历了abcd,mask就等于1111`,再次碰到`a~d`,就能通过&发现重复。
```cpp
    bool isUnique(string astr) {
        int mask = 0;
        for (auto c : astr) {
            int num = 1 << (c - 'a');
            if (mask & num) return false;
            else mask |= num;
        }
        return true;
    }

```


判定是否互为字符重排
=====================
[leetcode](https://leetcode-cn.com/problems/check-permutation-lcci/)
给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。
##### 解题思路
* 不用哈希表的方式，记录26个字母出现的频率，同时遍历两个字符串，一个加次数，一个减次数。最后看是否所有字母的次数为0。
```cpp
    bool CheckPermutation(string s1, string s2) {
        if (s1.size() != s2.size()) return false;
        int cnt[26];
        memset(cnt, 0, sizeof(int) * 26);
        for (int i = 0; i < s1.size(); ++i) {
            cnt[s1[i] - 'a']++;
            cnt[s2[i] - 'a']--;
        }
        for (int i = 0; i < 26; ++i) {
            if (cnt[i] != 0 ) return false;
        }
        return true;
    }
```


URL化
========
[leetcode](https://leetcode-cn.com/problems/string-to-url-lcci/)
URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。）
### 示例:
```
 输入："Mr John Smith    ", 13
 输出："Mr%20John%20Smith"
```
### 解题思路
* 理解题意很重要，在原数组的基础上进行修改，两种思路：从头开始或从尾部开始，既然原字符串在结尾已经给我预留了足够多的空位，那更方便从尾部开始插入。
* 维护两个指针，一个指向读入数据的位置（字符串真实长度的尾部），一个指向插入数据的位置（原字符串尾部）
* 读入数据进行判断，是空格，就在尾部连续插入3个字符'0''2''%',否则正常插入读入的数据。
* 最后，将修改后的结果从字符串中提取出来，`substr()`从写入指针最后停止的位置开始提取到尾部。
* substr()小技巧：如果没有指定长度或超出了源字符串的长度，则子字符串将延续到源字符串的结尾
```cpp
    string replaceSpaces(string S, int length) {
        int writePos = S.size() - 1;
        for (int i = 0; i < length; i++) {
            int readPos = length - 1 - i;
            if (S[readPos] != ' ') {
                S[writePos--] = S[readPos];
            } else {
                S[writePos--] = '0';
                S[writePos--] = '2';
                S[writePos--] = '%';
            }
        }
        if (writePos >= 0) {
            //S = S.substr(writePos + 1, S.size() - writePos - 1);
            S = S.substr(writePos + 1); 
        }
        return S;
    }
```

回文排列
========
[leetcode](https://leetcode-cn.com/problems/palindrome-permutation-lcci/)
给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。
回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。
回文串不一定是字典当中的单词。
### 解题思路
* 就是判断一个字符串能否变为一个回文串
* 统计每个字符出现的次数，偶数次数一定能组成回文，而奇数次数的字符只能有一个。
遍历每个字符，如果有2个以上包括2个的字母出现的次数为奇数，则不能变为回文。
```cpp
    bool canPermutePalindrome(string s) {
        map<char, int> cnt;
        for (auto ch : s) {
            cnt[ch]++;
        }
        int res = 0;
        for (auto m : cnt) {
            if (m.second % 2) res++;
            if (res > 1) return false;
        }
        return true;
    }
```

一次编辑
========
[leetcode](https://leetcode-cn.com/problems/one-away-lcci/)
字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。
### 示例
```
输入: 
first = "pale"
second = "ple"
输出: True

```
### 解题思路
* 能够通过增删换一次操作使两个字符相同的前提一定是，两个字符个数绝对差不超过1.
* 使用两个指针同时遍历两个字符，字幕相同就继续同时往后遍历
* 如果发现字母不同，cnt++记录需要操作的次数。
* 删除操作实质上就是指针跳过这个字符。至于是哪个指针进行跳过，就要就比较哪个字符串比较长，就删除哪个字符串的字符。
* 如果两个字符串长度相等，就只能进行替换操作，替换完，两个指针是要同时前进的
```cpp
    bool oneEditAway(string first, string second) {
        int len1 = first.size(), len2 = second.size();
        if (abs(len1 - len2) > 1) return false;
        int p1 = 0, p2 = 0;
        int cnt = 0;
        while (p1 <= len2 && p2 <= len2) {
            if (first[p1] == second[p2]) {
                p1++,p2++;continue;
            }
            len1 == len2 ? p1++,p2++ : len1 > len2 ? p1++ : p2++;
            cnt++;
            if (cnt > 1) return false;
        }
        return true;
    }

```


字符串压缩
==========
[leetcode](https://leetcode-cn.com/problems/compress-string-lcci/)
字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。
#### 示例
```
 输入："aabcccccaaa"
 输出："a2b1c5a3"
```
### 解题思路
* 遍历字符串，先取第一个字符作为当前值，从下标1开始遍历，统计与当前字符相等的个数。
* 当遍历不相等的字符时，更新当前值和个数
* 注意：因为每次遍历到不同的字符时，指针都会指向下一个字符，因此当遍历到最后一个字符时，需要跟字符串结尾的`\0`进行比较，所以遍历边界就不能再是`i < s.size()`应改为`i < size() + 1`。让i可以指向`\0`。

```cpp
    string compressString(string S) {
        if (S.size() <= 1) return S;
        char cur = S[0];
        string res = "";
        for (int i = 1; i < S.size() + 1; ++i) {
            int cnt = 1;
            res += cur;
            while (i < S.size() && S[i] == cur) cnt++, i++;
            cur = S[i];
            res += to_string(cnt);
        }
        return S.size() > res.size() ? res : S;
    }

```

旋转矩阵
===========
[leetcode](https://leetcode-cn.com/problems/rotate-matrix-lcci/)
给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。
不占用额外内存空间能否做到？
### 示例
```
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```
* 最简单的方式就是使用辅助矩阵，只要找到翻转后位置的对应关系即可，第row行变为第col行，第col列变为第n-1-row列（倒数的row列）
* `matrix[j][n-1-i] = matrix[i][j]`
```cpp
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        auto newMat = matrix;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                newMat[j][n - 1 - i] = matrix[i][j];
            }
        }
        matrix = newMat;
        return;
    }
```
* 如果面试要求原地进行翻转，首先要知道`matrix[j][n-1-i] = matrix[i][j]`会覆盖掉第2个点，
* 第一：因此我们需要先旋转第2个点，但第2点又会覆盖第3个点，所以先旋转第3点，第3点会覆盖第4点，第4个点刚好就是第1个点，形成一个循环，这样我们先记录第1个点，将后面得点依次覆盖，即可完成4个点得同时旋转。
* 第二：因为一次旋转4个点，所以我们需要知道遍历哪些点才能不重复。偶数边矩阵：最左上角的小矩阵，奇数矩阵：因为多了中间一列，所以选择最左上角的小矩阵 + 中间列。
```cpp
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < (n + 1) / 2; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - j - 1][i];
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                matrix[j][n - i - 1] = temp;
            }
        }
    }
```
* 用对折翻转代替旋转，这种算法除非做过原题，一般是想不到
* 先水平翻转，再对角线翻转
* 注意：翻转需要两个元素：1、翻转前后点得对应关系。2、枚举需要遍历的点。
```cpp
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        // 水平翻转
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < n; ++j) {
                swap(matrix[i][j], matrix[n - 1 - i][j]);
            }
        }
        // 对角线翻转
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
        return;
    }
```













 
 
 
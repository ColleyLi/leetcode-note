🎨程序员面试金典🎨
==================

* [1.判定字符是否唯一](#判定字符是否唯一)
* [2.判定是否互为字符重排](#判定是否互为字符重排)
* [3.URL化](#URL化)
* [4.回文排列](#回文排列)
* [5.一次编辑](#一次编辑)















判定字符是否唯一
=================
[leetcode](https://leetcode-cn.com/problems/is-unique-lcci/)实现一个算法，确定一个字符串 s 的所有字符是否全都不同。

### 解题思路
* 首先想到哈希表统计各字母出现频率，只遍历一次，频率大于1就返回false。
```cpp
    bool isUnique(string astr) {
        unordered_map<char, int> cnt;
        for (int i = 0; i < astr.size(); ++i) {
            cnt[astr[i]]++;
            if (cnt[astr[i]] > 1) return false;
        }
        return true;
    }
```
* 如果面试官不想用哈希表，或者不能用额外的数据结构解题，就用一个整形数组代替来记录26个字母出现次数。
```cpp
    bool isUnique(string astr) {
        int cnt[26];
        memset(cnt, 0, sizeof(int) * 26);
        for (int i = 0; i < astr.size(); ++i) {
            cnt[astr[i] - 'a']++;
            if (cnt[astr[i] - 'a'] > 1) return false;
        }
        return true;
    }
```
* 但是对于这种统计只出现一次，或者两次的题，都能够给位运算符操作
* 本题的思路是，把每个字母转换成二进制，例如 `a-> 0001 b -> 0010 c-> 0100 d->1000`一次类推剩下所有字母。
* 还需要维护一个掩码mask，将遍历过的所有字母的二进制数合并起来(|=运算)，`例如遍历了abcd,mask就等于1111`,再次碰到`a~d`,就能通过&发现重复。
```cpp
    bool isUnique(string astr) {
        int mask = 0;
        for (auto c : astr) {
            int num = 1 << (c - 'a');
            if (mask & num) return false;
            else mask |= num;
        }
        return true;
    }

```


判定是否互为字符重排
=====================
[leetcode](https://leetcode-cn.com/problems/check-permutation-lcci/)
给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。
##### 解题思路
* 不用哈希表的方式，记录26个字母出现的频率，同时遍历两个字符串，一个加次数，一个减次数。最后看是否所有字母的次数为0。
```cpp
    bool CheckPermutation(string s1, string s2) {
        if (s1.size() != s2.size()) return false;
        int cnt[26];
        memset(cnt, 0, sizeof(int) * 26);
        for (int i = 0; i < s1.size(); ++i) {
            cnt[s1[i] - 'a']++;
            cnt[s2[i] - 'a']--;
        }
        for (int i = 0; i < 26; ++i) {
            if (cnt[i] != 0 ) return false;
        }
        return true;
    }
```


URL化
========
[leetcode](https://leetcode-cn.com/problems/string-to-url-lcci/)
URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。）
### 示例:
```
 输入："Mr John Smith    ", 13
 输出："Mr%20John%20Smith"
```
### 解题思路
* 理解题意很重要，在原数组的基础上进行修改，两种思路：从头开始或从尾部开始，既然原字符串在结尾已经给我预留了足够多的空位，那更方便从尾部开始插入。
* 维护两个指针，一个指向读入数据的位置（字符串真实长度的尾部），一个指向插入数据的位置（原字符串尾部）
* 读入数据进行判断，是空格，就在尾部连续插入3个字符'0''2''%',否则正常插入读入的数据。
* 最后，将修改后的结果从字符串中提取出来，`substr()`从写入指针最后停止的位置开始提取到尾部。
* substr()小技巧：如果没有指定长度或超出了源字符串的长度，则子字符串将延续到源字符串的结尾
```cpp
    string replaceSpaces(string S, int length) {
        int writePos = S.size() - 1;
        for (int i = 0; i < length; i++) {
            int readPos = length - 1 - i;
            if (S[readPos] != ' ') {
                S[writePos--] = S[readPos];
            } else {
                S[writePos--] = '0';
                S[writePos--] = '2';
                S[writePos--] = '%';
            }
        }
        if (writePos >= 0) {
            //S = S.substr(writePos + 1, S.size() - writePos - 1);
            S = S.substr(writePos + 1); 
        }
        return S;
    }
```

回文排列
========
[leetcode](https://leetcode-cn.com/problems/palindrome-permutation-lcci/)
给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。
回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。
回文串不一定是字典当中的单词。
### 解题思路
* 就是判断一个字符串能否变为一个回文串
* 统计每个字符出现的次数，偶数次数一定能组成回文，而奇数次数的字符只能有一个。
遍历每个字符，如果有2个以上包括2个的字母出现的次数为奇数，则不能变为回文。
```cpp
    bool canPermutePalindrome(string s) {
        map<char, int> cnt;
        for (auto ch : s) {
            cnt[ch]++;
        }
        int res = 0;
        for (auto m : cnt) {
            if (m.second % 2) res++;
            if (res > 1) return false;
        }
        return true;
    }
```

一次编辑
========
[leetcode](https://leetcode-cn.com/problems/one-away-lcci/)
字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。
### 示例
```
输入: 
first = "pale"
second = "ple"
输出: True

```
### 解题思路
* 能够通过增删换一次操作使两个字符相同的前提一定是，两个字符个数绝对差不超过1.
* 使用两个指针同时遍历两个字符，字幕相同就继续同时往后遍历
* 如果发现字母不同，cnt++记录需要操作的次数。
* 删除操作实质上就是指针跳过这个字符。至于是哪个指针进行跳过，就要就比较哪个字符串比较长，就删除哪个字符串的字符。
* 如果两个字符串长度相等，就只能进行替换操作，替换完，两个指针是要同时前进的
```cpp
    bool oneEditAway(string first, string second) {
        int len1 = first.size(), len2 = second.size();
        if (abs(len1 - len2) > 1) return false;
        int p1 = 0, p2 = 0;
        int cnt = 0;
        while (p1 <= len2 && p2 <= len2) {
            if (first[p1] == second[p2]) {
                p1++,p2++;continue;
            }
            len1 == len2 ? p1++,p2++ : len1 > len2 ? p1++ : p2++;
            cnt++;
            if (cnt > 1) return false;
        }
        return true;
    }

```



 
 
 
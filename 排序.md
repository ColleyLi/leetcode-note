
451.按照字符出现次数对字符串排序
========================
[Leetcode](https://leetcode-cn.com/problems/sort-characters-by-frequency/)  
给定一个字符串，请将字符串里的字符按照出现的频率降序排列
* 遍历字符用map<char,int>获取字符频率，
* 创建大顶堆，遍历map根据pair的第一个参数降序添加到堆
* 循环弹出堆顶
```cpp
class Solution {
public:
    string frequencySort(string s) {
        map<char,int> frequencyMap;
        for(auto it:s){
            frequencyMap[it]++;
        }
        //堆根据第一个参数进行排序
        priority_queue<pair<int,char>> bigTopHeap;
        for(auto it:frequencyMap){
            //常用std::make_pair做函数参数创建pair
            bigTopHeap.push(make_pair(it.second,it.first));
        }
        string res;
        while(!bigTopHeap.empty()){
            pair<int ,char>top=bigTopHeap.top();
            int num=top.first;
            while(num>0){
                res+=top.second;
                num--;
            }
            bigTopHeap.pop();
        }
        return res;
    }
};
```
荷兰国旗
=============
[Leetcode](https://leetcode-cn.com/problems/sort-colors/)    
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
* 快速排序的变种（使用三指针）
```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int cur=0,p0=0;
        int p2=nums.size()-1;
        while(cur<=p2){
            if(nums[cur]==1){                   //遇到1，cur跳过
                cur++;
            }else if(nums[cur]==0){
                swap(nums[cur++],nums[p0++]);   //cur和p0都向后移动
            }else if(nums[cur]==2){
                swap(nums[cur],nums[p2--]);     //cur保持动，只有p2向前移动
            }
        }
    }
};
```

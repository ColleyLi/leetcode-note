动态规划
==============
 
 
70.爬楼梯  
==========
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？  
[Leetcode](https://leetcode-cn.com/problems/climbing-stairs/)  
* 到达第n阶台阶有两种方式，一个是在第`n-1`个台阶处+1阶或在`n-2个`台阶处+2阶
* 建立一个dp数组，记录到达每一层时的所有方法总数
* 所以到达第n个台阶的方法与到底第`n-1`和`n-2`个台阶相关，`dp[n]=dp[n-1]+dp[n-2]`
```cpp
    int climbStairs(int n) {
        vector<int> dp;
        for(int i=0;i<=n;++i){
            if(i==0) wayNums.push_back(1);
            else if(i==1) wayNums.push_back(2);
            else wayNums.push_back(dp[i-1]+dp[i-2]);
        }
        return dp.back();  
    }
```

198.打家劫舍
================
计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。  在不触动警报装置的情况下，能够偷窃到的最高金额。  
[Leetcode](https://leetcode-cn.com/problems/house-robber/)  
 * dp数组储存抢劫每户时的最大抢劫量，dp[i]表示抢到第i个房间时的最大抢劫量
 * 因为不能相邻抢劫，所以如果抢劫了`i-1`户，就不能抢劫第i户，或者是`i-2`户再加上当前户`i`
 * `dp[i]=max(dp[i-1],dp[i-2]+nums[i])`;
 * dp数组第一个值和第二个值分别为`nums[0]`和`max(nums[0].nums[1])`
 
```cpp
    int rob(vector<int>& nums) {
        if(nums.size()==0)return 0;
        vector<int> dp;
        for(int i=0;i<nums.size();i++){
            if(i==0) dp.push_back(nums[0]);           
            else if(i==1) dp.push_back(max(nums[0],nums[1]));
            else dp.push_back(max(dp[i-1],dp[i-2]+nums[i]));
        }
        return dp.back();
    }
```
213.打家劫舍 II  
================  
所有的房屋都围成一圈.  
[Leetcode](https://leetcode-cn.com/problems/house-robber-ii/)  
* 打劫问题升级版，因为是环形的，所以多了一个限制条件：
* 如果从第一户开始偷，那么最后一户就不能偷，下标:`0~n-2`
* 如果从第二户开始偷，最后一户就可以偷，下标为:`1~n-1`
* 环形问题分解为两条子序列，子序列使用动态规划，比较者最大值
```cpp
    int rob(vector<int>& nums) {
        if(nums.size()==0)return 0;
        if(nums.size()==1)return nums[0];
        return max(rob(nums,0,nums.size()-2),rob(nums,1,nums.size()-1));
    }
    int rob(vector<int>&nums,int left,int right){
        //根据left和right确定开辟dp数组的大小
        int cnt=left-right+1;
        vector<int> dp;
        //cur是dp数组的下标，不是nums的下标，cur从0，即dp的第一元素开始
        for(int cur=0;cur<cnt;cur++){
            if(cur==0)dp.push_back(nums[left]);
            else if(cur==1)dp.push_back(max(nums[left],nums[left+1]));
            else{//max里比的是dp数组里的值，不是nums数组的
                dp.push_back(max(dp[cur-1],dp[cur-2]+nums[left+cur]));
            }
        }
        return dp.back();
    }
```
